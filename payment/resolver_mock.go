// Code generated by MockGen. DO NOT EDIT.
// Source: resolver.go

// Package payment is a generated GoMock package.
package payment

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	order "go.citilink.cloud/order/internal/order"
)

// MockResolver is a mock of Resolver interface.
type MockResolver struct {
	ctrl     *gomock.Controller
	recorder *MockResolverMockRecorder
}

// MockResolverMockRecorder is the mock recorder for MockResolver.
type MockResolverMockRecorder struct {
	mock *MockResolver
}

// NewMockResolver creates a new mock instance.
func NewMockResolver(ctrl *gomock.Controller) *MockResolver {
	mock := &MockResolver{ctrl: ctrl}
	mock.recorder = &MockResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResolver) EXPECT() *MockResolverMockRecorder {
	return m.recorder
}

// Resolve mocks base method.
func (m *MockResolver) Resolve(ctx context.Context, resolvedIdsMap ResolvedPaymentIdMap, order order.Order) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", ctx, resolvedIdsMap, order)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockResolverMockRecorder) Resolve(ctx, resolvedIdsMap, order interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockResolver)(nil).Resolve), ctx, resolvedIdsMap, order)
}

// MockCompositePaymentResolver is a mock of CompositePaymentResolver interface.
type MockCompositePaymentResolver struct {
	ctrl     *gomock.Controller
	recorder *MockCompositePaymentResolverMockRecorder
}

// MockCompositePaymentResolverMockRecorder is the mock recorder for MockCompositePaymentResolver.
type MockCompositePaymentResolverMockRecorder struct {
	mock *MockCompositePaymentResolver
}

// NewMockCompositePaymentResolver creates a new mock instance.
func NewMockCompositePaymentResolver(ctrl *gomock.Controller) *MockCompositePaymentResolver {
	mock := &MockCompositePaymentResolver{ctrl: ctrl}
	mock.recorder = &MockCompositePaymentResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCompositePaymentResolver) EXPECT() *MockCompositePaymentResolverMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockCompositePaymentResolver) Add(resolver ...Resolver) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range resolver {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Add", varargs...)
}

// Add indicates an expected call of Add.
func (mr *MockCompositePaymentResolverMockRecorder) Add(resolver ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockCompositePaymentResolver)(nil).Add), resolver...)
}

// Resolve mocks base method.
func (m *MockCompositePaymentResolver) Resolve(ctx context.Context, ordr order.Order) (ResolvedPaymentIdMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", ctx, ordr)
	ret0, _ := ret[0].(ResolvedPaymentIdMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Resolve indicates an expected call of Resolve.
func (mr *MockCompositePaymentResolverMockRecorder) Resolve(ctx, ordr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockCompositePaymentResolver)(nil).Resolve), ctx, ordr)
}
